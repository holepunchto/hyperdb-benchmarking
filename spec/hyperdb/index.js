// This file is autogenerated by the hyperdb compiler
/* eslint-disable camelcase */

const { IndexEncoder, c } = require('hyperdb/runtime')
const { version, getEncoding, setVersion } = require('./messages.js')

// '@x/a' collection key
const collection0_key = new IndexEncoder([
  IndexEncoder.STRING,
  IndexEncoder.UINT
], { prefix: 0 })

function collection0_indexify (record) {
  const arr = []

  const a0 = record.c
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.d
  if (a1 === undefined) return arr
  arr.push(a1)

  return arr
}

// '@x/a' value encoding
const collection0_enc = getEncoding('@x/a/hyperdb#0')

// '@x/a' reconstruction function
function collection0_reconstruct (version, keyBuf, valueBuf) {
  const key = collection0_key.decode(keyBuf)
  setVersion(version)
  const record = c.decode(collection0_enc, valueBuf)
  record.c = key[0]
  record.d = key[1]
  return record
}
// '@x/a' key reconstruction function
function collection0_reconstruct_key (keyBuf) {
  const key = collection0_key.decode(keyBuf)
  return {
    c: key[0],
    d: key[1]
  }
}

// '@x/a'
const collection0 = {
  name: '@x/a',
  id: 0,
  encodeKey (record) {
    const key = [record.c, record.d]
    return collection0_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection0_key.encodeRange({
      gt: gt ? collection0_indexify(gt) : null,
      lt: lt ? collection0_indexify(lt) : null,
      gte: gte ? collection0_indexify(gte) : null,
      lte: lte ? collection0_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    setVersion(version)
    return c.encode(collection0_enc, record)
  },
  trigger: null,
  reconstruct: collection0_reconstruct,
  reconstructKey: collection0_reconstruct_key,
  indexes: []
}

// '@x/b' collection key
const collection1_key = new IndexEncoder([
  IndexEncoder.UINT
], { prefix: 1 })

function collection1_indexify (record) {
  const a = record.b
  return a === undefined ? [] : [a]
}

// '@x/b' value encoding
const collection1_enc = getEncoding('@x/b/hyperdb#1')

// '@x/b' reconstruction function
function collection1_reconstruct (version, keyBuf, valueBuf) {
  const key = collection1_key.decode(keyBuf)
  setVersion(version)
  const record = c.decode(collection1_enc, valueBuf)
  record.b = key[0]
  return record
}
// '@x/b' key reconstruction function
function collection1_reconstruct_key (keyBuf) {
  const key = collection1_key.decode(keyBuf)
  return {
    b: key[0]
  }
}

// '@x/b'
const collection1 = {
  name: '@x/b',
  id: 1,
  encodeKey (record) {
    const key = [record.b]
    return collection1_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection1_key.encodeRange({
      gt: gt ? collection1_indexify(gt) : null,
      lt: lt ? collection1_indexify(lt) : null,
      gte: gte ? collection1_indexify(gte) : null,
      lte: lte ? collection1_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    setVersion(version)
    return c.encode(collection1_enc, record)
  },
  trigger: null,
  reconstruct: collection1_reconstruct,
  reconstructKey: collection1_reconstruct_key,
  indexes: []
}

// '@x/c' collection key
const index2_key = new IndexEncoder([
  IndexEncoder.UINT,
  IndexEncoder.STRING,
  IndexEncoder.UINT
], { prefix: 2 })

function index2_indexify (record) {
  const arr = []

  const a0 = record.b
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.c
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.d
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@x/c'
const index2 = {
  name: '@x/c',
  id: 2,
  encodeKey (record) {
    return index2_key.encode(index2_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index2_key.encodeRange({
      gt: gt ? index2_indexify(gt) : null,
      lt: lt ? index2_indexify(lt) : null,
      gte: gte ? index2_indexify(gte) : null,
      lte: lte ? index2_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index2.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index2_key.encode([record.b, record.c, record.d])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection0.indexes.length,
  collection: collection0
}
collection0.indexes.push(index2)

// '@x/d' collection key
const index3_key = new IndexEncoder([
  IndexEncoder.STRING,
  IndexEncoder.STRING,
  IndexEncoder.UINT
], { prefix: 3 })

function index3_indexify (record) {
  const arr = []

  const a0 = record.c
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.c
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.d
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@x/d'
const index3 = {
  name: '@x/d',
  id: 3,
  encodeKey (record) {
    return index3_key.encode(index3_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index3_key.encodeRange({
      gt: gt ? index3_indexify(gt) : null,
      lt: lt ? index3_indexify(lt) : null,
      gte: gte ? index3_indexify(gte) : null,
      lte: lte ? index3_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index3.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index3_key.encode([record.c, record.c, record.d])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection0.indexes.length,
  collection: collection0
}
collection0.indexes.push(index3)

// '@x/e' collection key
const index4_key = new IndexEncoder([
  IndexEncoder.UINT,
  IndexEncoder.STRING,
  IndexEncoder.UINT
], { prefix: 4 })

function index4_indexify (record) {
  const arr = []

  const a0 = record.g
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.c
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.d
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@x/e'
const index4 = {
  name: '@x/e',
  id: 4,
  encodeKey (record) {
    return index4_key.encode(index4_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index4_key.encodeRange({
      gt: gt ? index4_indexify(gt) : null,
      lt: lt ? index4_indexify(lt) : null,
      gte: gte ? index4_indexify(gte) : null,
      lte: lte ? index4_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index4.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index4_key.encode([record.g, record.c, record.d])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection0.indexes.length,
  collection: collection0
}
collection0.indexes.push(index4)

// '@x/f' collection key
const index5_key = new IndexEncoder([
  IndexEncoder.STRING
], { prefix: 5 })

function index5_indexify (record) {
  const a = record.c
  return a === undefined ? [] : [a]
}

// '@x/f'
const index5 = {
  name: '@x/f',
  id: 5,
  encodeKey (record) {
    return index5_key.encode(index5_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index5_key.encodeRange({
      gt: gt ? index5_indexify(gt) : null,
      lt: lt ? index5_indexify(lt) : null,
      gte: gte ? index5_indexify(gte) : null,
      lte: lte ? index5_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index5.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index5_key.encode([record.c])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection1.indexes.length,
  collection: collection1
}
collection1.indexes.push(index5)

// '@x/g' collection key
const index6_key = new IndexEncoder([
  IndexEncoder.UINT,
  IndexEncoder.UINT
], { prefix: 6 })

function index6_indexify (record) {
  const arr = []

  const a0 = record.d
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.b
  if (a1 === undefined) return arr
  arr.push(a1)

  return arr
}

// '@x/g'
const index6 = {
  name: '@x/g',
  id: 6,
  encodeKey (record) {
    return index6_key.encode(index6_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index6_key.encodeRange({
      gt: gt ? index6_indexify(gt) : null,
      lt: lt ? index6_indexify(lt) : null,
      gte: gte ? index6_indexify(gte) : null,
      lte: lte ? index6_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index6.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index6_key.encode([record.d, record.b])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection1.indexes.length,
  collection: collection1
}
collection1.indexes.push(index6)

const collections = [
  collection0,
  collection1
]

const indexes = [
  index2,
  index3,
  index4,
  index5,
  index6
]

module.exports = { version, collections, indexes, resolveCollection, resolveIndex }

function resolveCollection (name) {
  switch (name) {
    case '@x/a': return collection0
    case '@x/b': return collection1
    default: return null
  }
}

function resolveIndex (name) {
  switch (name) {
    case '@x/c': return index2
    case '@x/d': return index3
    case '@x/e': return index4
    case '@x/f': return index5
    case '@x/g': return index6
    default: return null
  }
}
